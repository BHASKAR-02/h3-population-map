<!DOCTYPE html>
<html>
<head>
    <title>H3 Population Map - Canary Islands</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #map { height: 100vh; width: 100%; }
        
        .loading-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .legend {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .controls {
            position: absolute;
            top: 10px;
            left: 60px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="loading-indicator" id="loadingIndicator" style="display: none;">
        <div>Loading chunks: <span id="loadingProgress">0/0</span></div>
        <div><small id="loadingStatus">Initializing...</small></div>
    </div>
    
    <div class="controls">
        <button onclick="loadAllChunks()">Load All Data</button>
        <button onclick="clearData()">Clear Data</button>
        <br><small>Chunks loaded: <span id="chunksLoaded">0</span></small>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // Initialize map with standard WGS84 projection
        var map = L.map('map').setView([28.08, -14.37], 10); // Canary Islands
        
        // Add base tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 18
        }).addTo(map);
        
        // Global variables
        var loadedLayers = [];
        var chunksData = null;
        var loadingIndicator = document.getElementById('loadingIndicator');
        var loadingProgress = document.getElementById('loadingProgress');
        var loadingStatus = document.getElementById('loadingStatus');
        var chunksLoadedSpan = document.getElementById('chunksLoaded');
        
        // Function to convert EPSG:3857 coordinates to EPSG:4326 (lat/lon)
        function webMercatorToLatLng(x, y) {
            var lng = (x / 20037508.34) * 180;
            var lat = (y / 20037508.34) * 180;
            lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);
            return [lat, lng];
        }
        
        // Function to transform coordinates in a geometry
        function transformGeometry(geometry) {
            if (geometry.type === 'Polygon') {
                return {
                    type: 'Polygon',
                    coordinates: geometry.coordinates.map(ring =>
                        ring.map(coord => {
                            var latLng = webMercatorToLatLng(coord[0], coord[1]);
                            return [latLng[1], latLng[0]]; // [lng, lat] for GeoJSON
                        })
                    )
                };
            }
            // Add other geometry types if needed
            return geometry;
        }
        
        // Load chunks index
        fetch('./h3_geojson_chunks/chunks_index.json')
            .then(response => response.json())
            .then(data => {
                chunksData = data;
                console.log(`Found ${data.total_chunks} chunks with ${data.total_features} features (${data.total_size_mb} MB total)`);
                loadingStatus.textContent = `${data.total_chunks} chunks available (${data.total_size_mb} MB)`;
            })
            .catch(error => {
                console.error('Error loading chunks index:', error);
                loadingStatus.textContent = 'Error loading data index';
            });
        
        // Color function based on population values
        function getColor(population) {
            return population > 100 ? '#800026' :
                   population > 80  ? '#BD0026' :
                   population > 60  ? '#E31A1C' :
                   population > 40  ? '#FC4E2A' :
                   population > 20  ? '#FD8D3C' :
                   population > 10  ? '#FEB24C' :
                   population > 5   ? '#FED976' :
                                     '#FFEDA0';
        }
        
        // Style function
        function styleFeature(feature) {
            var population = feature.properties.population || 0;
            return {
                fillColor: getColor(population),
                weight: 0.5,
                opacity: 1,
                color: 'white',
                fillOpacity: 0.7
            };
        }
        
        // Popup function
        function onEachFeature(feature, layer) {
            var popupContent = `
                <div style="font-family: Arial, sans-serif;">
                    <strong>H3 Index:</strong><br>
                    <code style="font-size: 0.9em; background: #f5f5f5; padding: 2px 4px; word-break: break-all;">${feature.properties.h3}</code><br><br>
                    <strong>Population:</strong> ${feature.properties.population}
                </div>
            `;
            layer.bindPopup(popupContent);
        }
        
        // Load a single chunk with coordinate transformation
        function loadChunk(chunkInfo, index, total) {
            return fetch(`./h3_geojson_chunks/${chunkInfo.filename}`)
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    // Transform coordinates from EPSG:3857 to EPSG:4326
                    var transformedData = {
                        ...data,
                        crs: {
                            type: "name",
                            properties: {
                                name: "urn:ogc:def:crs:EPSG::4326"
                            }
                        },
                        features: data.features.map(feature => ({
                            ...feature,
                            geometry: transformGeometry(feature.geometry)
                        }))
                    };
                    
                    var layer = L.geoJSON(transformedData, {
                        style: styleFeature,
                        onEachFeature: onEachFeature
                    }).addTo(map);
                    
                    loadedLayers.push(layer);
                    
                    // Update progress
                    loadingProgress.textContent = `${index + 1}/${total}`;
                    chunksLoadedSpan.textContent = loadedLayers.length;
                    loadingStatus.textContent = `Loaded ${chunkInfo.filename} (${chunkInfo.features} features)`;
                    
                    return layer;
                })
                .catch(error => {
                    console.error(`Error loading chunk ${chunkInfo.filename}:`, error);
                    loadingStatus.textContent = `Error loading ${chunkInfo.filename}`;
                    throw error;
                });
        }
        
        // Load all chunks
        async function loadAllChunks() {
            if (!chunksData) {
                alert('Chunks data not ready. Please wait...');
                return;
            }
            
            loadingIndicator.style.display = 'block';
            loadingProgress.textContent = `0/${chunksData.chunks.length}`;
            
            try {
                // Load chunks sequentially
                for (let i = 0; i < chunksData.chunks.length; i++) {
                    await loadChunk(chunksData.chunks[i], i, chunksData.chunks.length);
                    // Small delay to allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                // Fit map to all loaded data
                if (loadedLayers.length > 0) {
                    var group = new L.featureGroup(loadedLayers);
                    map.fitBounds(group.getBounds(), { padding: [20, 20] });
                }
                
                loadingStatus.textContent = `All ${loadedLayers.length} chunks loaded successfully!`;
                setTimeout(() => {
                    loadingIndicator.style.display = 'none';
                }, 3000);
                
            } catch (error) {
                console.error('Error loading chunks:', error);
                loadingStatus.textContent = 'Error loading some chunks';
            }
        }
        
        // Clear all loaded data
        function clearData() {
            loadedLayers.forEach(layer => map.removeLayer(layer));
            loadedLayers = [];
            chunksLoadedSpan.textContent = '0';
            loadingStatus.textContent = 'Data cleared';
        }
        
        // Add legend
        var legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'legend'),
                grades = [0, 5, 10, 20, 40, 60, 80, 100],
                labels = [];

            div.innerHTML += '<strong>Population</strong><br>';
            
            for (var i = 0; i < grades.length; i++) {
                div.innerHTML +=
                    '<div style="margin: 2px 0;"><i style="background:' + getColor(grades[i] + 1) + 
                    '; width: 18px; height: 18px; display: inline-block; margin-right: 8px; border: 1px solid #ccc;"></i> ' +
                    grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] : '+') + '</div>';
            }
            return div;
        };
        legend.addTo(map);
        
        // Add scale control
        L.control.scale().addTo(map);
        
        // Load first chunk automatically to show something immediately
        setTimeout(() => {
            if (chunksData && chunksData.chunks.length > 0) {
                loadChunk(chunksData.chunks[0], 0, 1)
                    .then(() => {
                        console.log('First chunk loaded automatically');
                        if (loadedLayers.length > 0) {
                            var group = new L.featureGroup(loadedLayers);
                            map.fitBounds(group.getBounds(), { padding: [20, 20] });
                        }
                    })
                    .catch(console.error);
            }
        }, 1000);
    </script>
</body>
</html>
